--[[
    Automatically generate C file definitions given TPC-H generated
    data, i.e. for tpch-dbgen/lineitem.tbl it will generate
    lineite,h and lineitem.c with structure defined and array filled.

```
    luajit tools/tbl2c.lua -N $(echo 8*1024|bc) -f 13
```
    If you need to generate compact form (i.e. single field) then
    use `-f N` option. In this example we generate lineitem.c with
    only `l_receiptdate` (#13) field generated.
]]
local getopt = require 'getopt'

local nonoptions = {}
local linesN
local fieldN

local function show_usage()
    print(arg[-1] .. ' ' .. arg[0],
        [[

            Usage: N:

            -N N .. number of lines to read (if not all)
            -f N compact version, for single column #N
        ]]
    )
end

for opt, arg in getopt(arg, 'N:p:f:', nonoptions) do
    if opt == 'N' then
        linesN = tonumber(arg)
    elseif opt == 'f' then
        fieldN = tonumber(arg)
    elseif opt == '?' then
        show_usage()
        os.exit(1)
    end
end

local autogen_header = [[
/* %s is automatically generated by tbl2c.lua */
]]

local template_header = [[
#ifdef __cplusplus
extern "C" {
#endif

struct datetime {
    int year, month, day;
};

struct lineitem {
        long l_orderkey;
        long l_partkey;
        long l_suppkey;
        long l_linenumber;
        long l_quantity;
        double l_extendedprice;
        double l_discount;
        double l_tax;
        const char * l_returnflag;
        const char * l_linestatus;
        struct datetime l_shipdate;
        struct datetime l_commitdate;
        struct datetime l_receiptdate;
        const char * l_shipinstruct;
        const char * l_shipmode;
        const char * l_comment;
};

%s

#ifdef __cplusplus
}
#endif

]]

local template_for_row = [[
    {
        %d, %d, %d, %d, %d, %g, %g, %g, "%s", "%s",
        {%d, %d, %d}, {%d, %d, %d}, {%d, %d, %d},
        "%s", "%s", "%s"
    },
]]

local template_for_1row = [[
    { .%s = %s },
]]
local template_for_extern_array = [[
extern const struct lineitem %s[];
]]

local template_for_array_begin = [[
#include "%s.h"

const struct lineitem %s[] = {
]]

local template_for_array_end = [[
};
]]

local tables = {
    'lineitem',
}

local l_orderkey = 1
local l_partkey = 2
local l_suppkey = 3
local l_linenumber = 4
local l_quantity = 5
local l_extendedprice = 6
local l_discount = 7
local l_tax = 8
local l_returnflag = 9
local l_linestatus = 10
local l_shipdate = 11
local l_commitdate = 12
local l_receiptdate = 13
local l_shipinstruct = 14
local l_shipmode = 15
local l_comment = 16

local f_names = {
    'l_orderkey',
    'l_partkey',
    'l_suppkey',
    'l_linenumber',
    'l_quantity',
    'l_extendedprice',
    'l_discount',
    'l_tax',
    'l_returnflag',
    'l_linestatus',
    'l_shipdate',
    'l_commitdate',
    'l_receiptdate',
    'l_shipinstruct',
    'l_shipmode',
    'l_comment',
}

for _, tblname in ipairs(tables) do
    local f = assert(io.open(string.format("tpch-dbgen/%s.tbl", tblname), 'rb'))
    print(tblname)
    -- header file
    local headername = string.format('%s.h', tblname)
    local outh = assert(io.open(headername, "w"))
    -- c file
    local cfilename = string.format('%s.c', tblname)
    local outf = assert(io.open(cfilename, "w"))

    outh:write(autogen_header:format(headername))
    outf:write(autogen_header:format(cfilename))

    outh:write(template_header:format(template_for_extern_array:format(tblname)))
    outf:write(template_for_array_begin:format(tblname, tblname))
    outh:close()

    local i = 0
    while true do
        local line = f:read('*line')
        if not line then break end
        i = i + 1
        if i > linesN then break end
        io.write('.')
        if i % 1000 == 0 then print("\n"..i) end

        local next = string.gmatch(line, '[^|]+')

        -- capture generator next()
        local function get_long()
            return tonumber(next())
        end

        local function get_double()
            return tonumber(next())
        end

        local function get_string()
            return next()
        end

        local function get_date()
            local year, month, day = string.match(next(), '(%d+)-(%d+)-(%d+)')
            return { tonumber(year), tonumber(month), tonumber(day) }
        end

        local function field_as_text(data)
            if type(data) == 'string' then
                return ('"%s"'):format(data)
            elseif type(data) == 'number' then
                return ('%g'):format(data)
            elseif type(data) == 'table' then
                return ('{%d, %d, %d}'):format(data[1], data[2], data[3])
            end
        end


        local f = {}
        f[l_orderkey] = get_long()
        f[l_partkey] = get_long()
        f[l_suppkey] = get_long()
        f[l_linenumber] = get_long()
        f[l_quantity] = get_double()
        f[l_extendedprice] = get_double()
        f[l_discount] = get_double()
        f[l_tax] = get_long()
        f[l_returnflag] = get_string()
        f[l_linestatus] = get_string()
        f[l_shipdate] = get_date()
        f[l_commitdate] = get_date()
        f[l_receiptdate] = get_date()
        f[l_shipinstruct] = get_string()
        f[l_shipmode] = get_string()
        f[l_comment] = get_string()

        if fieldN ~= nil then   -- output single field
            outf:write(template_for_1row:format(
                f_names[fieldN], field_as_text(f[fieldN]))
            )
        else                    -- output all fields
            outf:write(template_for_row:format(
                f[l_orderkey], f[l_partkey], f[l_suppkey], f[l_linenumber],
                f[l_quantity], f[l_extendedprice], f[l_discount], f[l_tax],
                f[l_returnflag], f[l_linestatus],
                f[l_shipdate][1], f[l_shipdate][2], f[l_shipdate][3],
                f[l_commitdate][1], f[l_commitdate][2], f[l_commitdate][3],
                f[l_receiptdate][1], f[l_receiptdate][2], f[l_receiptdate][3],
                f[l_shipinstruct], f[l_shipmode], f[l_comment])
            )
        end
    end
    outf:write(template_for_array_end:format(tblname))
    f:close()
    outf:close()
end

os.exit(0)

